package com.stayprime.hibernate.entities;
// Generated Sep 17, 2014 5:18:02 PM by Hibernate Tools 4.3.1

import com.stayprime.geo.BasicMapImage;
import com.stayprime.geo.Coordinates;
import java.awt.Color;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.JoinColumn;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import com.stayprime.util.gson.Exclude;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Set;
import javax.persistence.Transient;

/**
 * Holes generated by hbm2java
 */
@Entity
@Table(name = "holes")
public class Holes implements java.io.Serializable {

    @EmbeddedId
    @AttributeOverrides({
        @AttributeOverride(name = "course", column = @Column(name = "course", nullable = false))
        ,
        @AttributeOverride(name = "hole", column = @Column(name = "hole", nullable = false))
    })
    private HolesId id;

    @Exclude
    @Transient
    private Courses course;

    private int par;

    private int paceOfPlay;

    private boolean cartPathOnly;

    private String description;

    @Column(length = 1000)
    private String proTips = "";

    private String mapImage;

    private String flyoverImage;

    private String cornerTopLeft;

    private String cornerTopRight;

    private String cornerBottomLeft;

    private String cornerBottomRight;

    @Temporal(TemporalType.TIMESTAMP)
    @Column(nullable = false)
    private Date updated = new Date();

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "tee_boxes", joinColumns = {
        @JoinColumn(name = "course")
        , @JoinColumn(name = "hole")})
    @OrderBy("number")
    private List<TeeBoxes> teeBoxes;

    private int strokeIndex;

    public Holes() {
    }

    public Holes(Courses course, int number) {
        this.id = new HolesId(course.getNumber(), number);
    }

    public HolesId getId() {
        return this.id;
    }

    public void setId(HolesId id) {
        this.id = id;
    }

    public Courses getCourse() {
        return this.course;
    }

    public void setCourse(Courses courses) {
        this.course = courses;
    }

    public int getPar() {
        return this.par;
    }

    public void setPar(int par) {
        this.par = par;
    }

    public int getPaceOfPlay() {
        return this.paceOfPlay;
    }

    public void setPaceOfPlay(int paceOfPlay) {
        this.paceOfPlay = paceOfPlay;
    }

    public boolean isCartPathOnly() {
        return this.cartPathOnly;
    }

    public void setCartPathOnly(boolean cartPathOnly) {
        this.cartPathOnly = cartPathOnly;
    }

    public String getDescription() {
        return this.description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getProTips() {
        return this.proTips;
    }

    public void setProTips(String proTips) {
        this.proTips = proTips;
    }

    public String getMapImage() {
        return this.mapImage;
    }

    public void setMapImage(String mapImage) {
        this.mapImage = mapImage;
    }

    public String getFlyoverImage() {
        return this.flyoverImage;
    }

    public void setFlyoverImage(String flyoverImage) {
        this.flyoverImage = flyoverImage;
    }

    public String getCornerTopLeft() {
        return this.cornerTopLeft;
    }

    public void setCornerTopLeft(String cornerTopLeft) {
        this.cornerTopLeft = cornerTopLeft;
    }

    public String getCornerTopRight() {
        return this.cornerTopRight;
    }

    public void setCornerTopRight(String cornerTopRight) {
        this.cornerTopRight = cornerTopRight;
    }

    public String getCornerBottomLeft() {
        return this.cornerBottomLeft;
    }

    public void setCornerBottomLeft(String cornerBottomLeft) {
        this.cornerBottomLeft = cornerBottomLeft;
    }

    public String getCornerBottomRight() {
        return this.cornerBottomRight;
    }

    public void setCornerBottomRight(String cornerBottomRight) {
        this.cornerBottomRight = cornerBottomRight;
    }

    public Date getUpdated() {
        return this.updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }

    public int getStrokeIndex() {
        return this.strokeIndex;
    }

    public void setStrokeIndex(int strokeIndex) {
        this.strokeIndex = strokeIndex;
    }

    public List<TeeBoxes> getTeeBoxes() {
        return teeBoxes == null ? Collections.EMPTY_LIST : teeBoxes;
    }

    public void setTeeBoxes(List<TeeBoxes> teeBoxes) {
        this.teeBoxes = teeBoxes;
    }

    public TeeBoxes createTeeBox() {
//        int missing;
//        int no=1;
//        for(TeeBoxes teeBox:teeBoxes){
//            if(no!=teeBox.getNumber()) break;
//            no++;
//        }
        List<TeeBoxes> mTeeBoxes = teeBoxes;
        if (mTeeBoxes != null) {
            mTeeBoxes.sort(new Comparator<TeeBoxes>() {
                @Override
                public int compare(TeeBoxes t, TeeBoxes t1) {

                    return t.getNumber() - t1.getNumber();
                    //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                }

            });
        }
        int no = 1;
        if (mTeeBoxes != null) {
            for (TeeBoxes teeBox : mTeeBoxes) {
                if (no != teeBox.getNumber()) {
                    break;
                }
                no++;
            }
        }
        TeeBoxes teeBox = new TeeBoxes(this, no);
        teeBox.setColor(Color.white.getRGB());
        return teeBox;
    }

    /**
     * Convenience method to get BasicMapImage instance from this hole.
     *
     * @return a BasicMapImage representing this hole
     */
    public BasicMapImage getMap() {
        return new BasicMapImage(getMapImage(),
                Coordinates.fromString(getCornerTopLeft()),
                Coordinates.fromString(getCornerTopRight()),
                Coordinates.fromString(getCornerBottomLeft()),
                Coordinates.fromString(getCornerBottomRight())
        );
    }

    /**
     * Convenience method to set this hole properties from a BasicMapImage.
     *
     * @param map the map to set image source and coordinates from
     */
    public void setMap(BasicMapImage map) {
        mapImage = map == null ? null : map.getImageAddress();
        boolean invalid = map == null || !map.hasFourCornerCoordinates();
        cornerTopLeft = invalid ? null : map.getTopLeft().toString();
        cornerTopRight = invalid ? null : map.getTopRight().toString();
        cornerBottomLeft = invalid ? null : map.getBottomLeft().toString();
        cornerBottomRight = invalid ? null : map.getBottomRight().toString();
    }

    public static Holes findByNumber(List<Holes> holes, int n) {
        if (holes != null) {
            for (Holes h : holes) {
                if (h.getId().getHole() == n) {
                    return h;
                }
            }
        }
        return null;
    }

    /**
     * Method to compare 2 holes by their ids
     *
     * @return
     */
    public static boolean isFirstHoleGreater(HolesId h1, HolesId h2) {
        if (h1.getCourse() > h2.getCourse()) {
            return true;
        } else if (h1.getCourse() == h2.getCourse() && h1.getHole() > h2.getHole()) {
            return true;
        } else {
            return false;
        }
    }

    public static List<Holes> getSortedHolesList(Set<Holes> holesSet) {
        List<Holes> holes = new ArrayList<>();
        for (Holes hole : holesSet) {
            holes.add(hole);
        }
        for (int i = 0; i < holes.size() - 1; i++) {
            for (int j = 0; j < holes.size() - 1 - i; j++) {
                Holes h1 = holes.get(j);
                Holes h2 = holes.get(j + 1);
                if (isFirstHoleGreater(h1.getId(), h2.getId())) {
                    Holes temp = h1;
                    holes.set(j, h2);
                    holes.set(j + 1, temp);
                }
            }
        }
        return holes;
    }

}
